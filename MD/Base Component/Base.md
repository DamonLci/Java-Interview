# 1.面向对象的特性
继承，封装，多态，（抽象）
# 2.new对象和clone对象的区别
new:当你new一个对象是，你先得到对象，再得到对象的类型，分配空间，内存，再调用构造函数，初始化对象，对象创建完毕，引用地址发布到外部，在外部就可以操作使用这个对象。
clone:clone第一步仍然是分配内存，但是是使用原对象的域进行填充新的域，再clone方法返回，一个新的相同的对象被创建。
clone对象是完全new一个对象，地址也不同
#3.浅拷贝和深拷贝
浅拷贝是指指向你拷贝对象的引用地址
深拷贝是指new一个对象，再指向这个新的对象。
#4.&和&&区别
&&是短路与，两边任何一个为false都会为false，例如验证用户名是否正确
&是逻辑与和按位与
#5.==和equal的区别
==如果是比较基本类型，则比较数值是否相等 如果是引用数据类型 则比较对象的地址是否相等
equal则是比较两个对象内容是否相等
#6.String对象能否被引用
String对象是属于final类.不可以被继承，对string类最好的方式是关联关系，而不是依赖关系
#7.重载（overload）和重写（override）的区别？重载的方法能否根据返回类进行区分
重载和重写都是多态的实现方式，前者是编译时候的多态，后者是运行时候的多态，
重载要求在同一个类中，并且要求同名的方法要求有不同的参数列表，包括参数的类型
重写发生在父类和子类中，重写要求子类被重写的方法和父类被重写的方法有一样的返回值，重载对返回值没有任何要求
方法重载的规则
1.重载要求在同一个类，且方法名一致，且参数列表不同 包括参数类型
2.重载与返回值无关
3,重载可以抛出异常，有不同的修饰符。
方法重写的规则
1,参数列表必须要和被重写的方法一致，返回类型必须和被重写方法返回类型一致。
2,构造方法不能被重写，声明为final的方法不能被重写，申明为static的方法不能被重写，但是能被再次声明
3.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是 否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则 可以。
8.final,finally,finalize
final用于声明属性和方法和类 分别表示 属性不变，方法不可覆盖，类不可被继承
finally 异常处理的一部分 表示总是继承
finalize 是object类的一个方法主要是用于关闭文件 一个对象的生命周期结束这一类的方法。
9.equals和hash code的联系
两个对象，如果 equals对比相同，那么它们的hashcode一定相同，
如果hashcode相同，但是equals并不一定相同。
equals满足自反性，对称性，传递性。
10.abstract 抽象类和interface接口有什么异同
1.抽象类：
抽象类可以定义构造类
抽象类可以有抽象的方法和具体的方法
接口的成员全是public但是抽象类的成员可以是public privated protected等
抽象类包括静态static的方法
抽象类可以定义成员变量
一个类继承一个抽象类
2接口类
接口类不能定义构造器
方法全是抽象的方法
接口的成员变量全是常量
接口不能有static的变量
相同
都不能实例化
一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法进行全部实现，否者该类还是被声明为抽象类

#11.静态变量与实例变量的区别

#12.成员变量和局部变量
成员变量：
在类体里面定义的变量叫做成员变量；
如果在变量有static关键字修饰，就叫作静态变量或类变量；
如果该变量没有static关键字修饰，就叫作非静态变量或实例变量；
局部变量:
方法内定义的变量、形参、代码块中定义的变量都叫做局部变量；
另外，成员变量可以不显式初始化，它们可以由系统设定默认值；局部变量没有默认值，所以必须设定初始赋值。
还有，在内存中的位置也不一样。成员变量在所在类被实例化后，存在堆内存中；局部变量在所在方法调用时，存在栈内存空间中。
#13.throw 和 throws 的区别


1）throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。
 2）throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常。 
throws：
 1）throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。 
2）throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。
 3）throws 表示出现异常的一种可能性，并不一定会发生这种异常。
eg1:
public int deluser(User user){
		int result =userDao.deluser(user);
		if(result>0){
			return result;
		}
		else {
			//throw new RuntimeException("删除失败");
		}
	}
eg2:
		try {
			userService.deluser(user);
			request.setAttribute("message", "删除成功");
		} catch (Exception e) {
			// TODO: handle exception
			request.setAttribute("message", e.getMessage());
		}

#14.java四舍五入的原理
四舍五入的原理是在参数上加 0.5 然后进行取整。
15.数组有没有 length() 方法？String 有没有 length() 方法？
数组没有length()方法，但是有length属性，String有length()方法.js获取长度用的是length属性。
#16.String，Stringbuffer，StringBuilder有什么区别
String属于只读字符串，无法进行写入修改操作，String属于引用对象，只是引用到了这个对象的地址，而无法更改，但是StringBuffer和StringBuilder可以直接对字符串进行修改，
StringBuilder是属于在单线程里面使用，他的所有方法都没有被synchronized方法修饰，运行效率比StringBuffer要高。
在For循环中，使用StringBuffer比+要好点，因为+会创建一个StringBuffer对象，For循环一次就会出现一次，这样会创建很多StringBuffer 会导致系统占用大量资源，所以在循环中建议使用StringBuffer的append()方法;
#17.如何实现对象的clone；
1，继承cloneable接口并重写object中的clone()方法；
2，实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，




